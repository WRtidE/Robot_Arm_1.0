# 机械臂开发文档

## 电控部分

### 时钟树配置

![时钟树配置](img\时钟树配置.png)

### 蓝牙DMA接收

![串口6配置1](img\串口6配置1.png)

- Uart_user.c

```C
#include "stm32f4xx.h"                  // Device header
#include "Uart_user.h"
#include "usart.h"
#include "control_data.h"

void data_send();
void data_receive();

//串口6通信
uint8_t data_length = 17;
uint8_t rx_buffer_ch05[17];
uint8_t tx_buffer_ch05[17];

Control_Data data;


void data_receive_IT()
{
	//接受空闲中断
  
	__HAL_UART_ENABLE_IT(&huart6, UART_IT_IDLE); 
	
	HAL_UART_Receive_DMA(&huart6, rx_buffer_ch05,data_length);
  HAL_Delay(1000);
}

//串口接收中断
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{  
	if(huart->Instance==USART6)
	{	 
   //接收蓝牙模块数据包
      static uint8_t RxState=0;
		
			if(RxState==0)
      { 
           if(rx_buffer_ch05[0]==0xA5)
           {
               RxState=1;
           } 
			}
      if(RxState==1)
      {  
				//APP数据处理
				 data.x = (rx_buffer_ch05[2]<<8)|rx_buffer_ch05[1];
				 data.y = (rx_buffer_ch05[4]<<8)|rx_buffer_ch05[3];
				 data.z = (rx_buffer_ch05[6]<<8)|rx_buffer_ch05[5];
				 data.v_int[0] = (rx_buffer_ch05[8]<<8)|rx_buffer_ch05[7];
				 data.v_int[1] = (rx_buffer_ch05[10]<<8)|rx_buffer_ch05[9];
				 data.v_int[2] = (rx_buffer_ch05[12]<<8)|rx_buffer_ch05[11];
				 data.v_int[3] = (rx_buffer_ch05[14]<<8)|rx_buffer_ch05[13];
				
         RxState=2;
			}
      if(RxState==2)
      {
          if(rx_buffer_ch05[data_length-1]==0x5A)
         { 
				   RxState=0;
				 }
				 HAL_UART_Receive_DMA(&huart6,rx_buffer_ch05,data_length);
			}
		  
	}	
}
```

- control_data.h

```c
#ifndef __CONTROL_DATA_H
#define __CONTROL_DATA_H

typedef __packed struct
{
	//机械臂位置信息
  int16_t x;
	int16_t y;
	int16_t z;
	
	//速度控制
	int16_t v_int[4];     
	
	//按键信息
	int16_t key[6];       
		
} Control_Data;

extern Control_Data data;



#endif

```

### SG90舵机

因为TIM3定时器是APB1，根据时钟树可以知道其频率为84Mhz

计算公式如下：

![定时器计算](img\定时器计算.png)

![舵机PWM定时器](img\舵机PWM定时器.png)

- Servos.c

```C
#include "stm32f4xx.h" 
#include "Servos.h"
#include "tim.h"


void servos_init()
{
	HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_4);
}

//500 --0   1000 -- 45   1500 --90   2000 ---135  2500 --180 

void servos_control(uint16_t angle)
{
	float temp;
	temp = angle*(2500/127);
	if(temp<0)
	{
		temp=-temp;
	}
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_4, temp);
}

```



### 电机can通信

- Can_User.c

```c
#include "stm32f4xx.h"                  // Device header
#include "Can_user.h"
#include "can.h"
#include "bsp_can.h"

motor_info_t motor_info[4];
 
uint8_t Data_Enable[8]     ={0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC};		//电机使能命令
uint8_t Data_Failure[8]    ={0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD};		//电机失能命令
uint8_t Data_Save_zero[8]  ={0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE};	  //电机保存零点命令
uint8_t Data_Error_clear[8]={0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB};	  //电机清除错误

//============================电机基础命令===============================================

//电机命令
/*
    Data_Enable        电机使能命令
		Data_Failure			 电机失能命令
		Data_Save_zero     电机保存零点命令
		Data_Error_clear   电机清除错误
*/
void motor_commend(motor_info_t motor,uint8_t *pData)
{
	if(motor.mode== 0)  //MIT模式
	{
		CANx_SendStdData(&hcan1,motor.can_id,pData,8);	
		HAL_Delay(10);
	}
	if(motor.mode== 1)  //位置速度模式
	{
		CANx_SendStdData(&hcan1,motor.can_id + 0x100,pData,8);	
		HAL_Delay(10);
	}
	if(motor.mode== 2) //速度模式
	{
		CANx_SendStdData(&hcan1,motor.can_id + 0x200,pData,8);	
		HAL_Delay(10);
	}
}
//============================can相关===============================================
//can滤波器
void can_filter_init(void)
{

    CAN_FilterTypeDef can_filter_st;
    can_filter_st.FilterActivation = ENABLE;
    can_filter_st.FilterMode = CAN_FILTERMODE_IDMASK;
    can_filter_st.FilterScale = CAN_FILTERSCALE_32BIT;
    can_filter_st.FilterIdHigh = 0x0000;
    can_filter_st.FilterIdLow = 0x0000;
    can_filter_st.FilterMaskIdHigh = 0x0000;
    can_filter_st.FilterMaskIdLow = 0x0000;
    can_filter_st.FilterBank = 0;
    can_filter_st.FilterFIFOAssignment = CAN_RX_FIFO0;
    HAL_CAN_ConfigFilter(&hcan1, &can_filter_st);
    HAL_CAN_Start(&hcan1);
    HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);


    can_filter_st.SlaveStartFilterBank = 14;
    can_filter_st.FilterBank = 14;
    HAL_CAN_ConfigFilter(&hcan2, &can_filter_st);
    HAL_CAN_Start(&hcan2);
    HAL_CAN_ActivateNotification(&hcan2, CAN_IT_RX_FIFO0_MSG_PENDING);
}



/**
 * @brief  发送标准ID的数据帧
 * @param  hcan     CAN的句柄
 * @param  ID       数据帧ID
 * @param  pData    数组指针
 * @param  Len      字节数0~8
 */
uint8_t CANx_SendStdData(CAN_HandleTypeDef* hcan,uint16_t ID,uint8_t *pData,uint16_t Len)
{
  static CAN_TxHeaderTypeDef   Tx_Header;
	
	Tx_Header.StdId=ID;
	Tx_Header.ExtId=0;
	Tx_Header.IDE=0;
	Tx_Header.RTR=0;
	Tx_Header.DLC=Len;
	
	
        /*找到空的发送邮箱，把数据发送出去*/
	if(HAL_CAN_AddTxMessage(hcan, &Tx_Header, pData, (uint32_t*)CAN_TX_MAILBOX0) != HAL_OK) //
	{
		if(HAL_CAN_AddTxMessage(hcan, &Tx_Header, pData, (uint32_t*)CAN_TX_MAILBOX1) != HAL_OK)
		{
			HAL_CAN_AddTxMessage(hcan, &Tx_Header, pData, (uint32_t*)CAN_TX_MAILBOX2);
        }
    }
    return 0;
}

//======================================================================================


```

- can_bsp

  ```C
   * @brief: CAN Receive Message.
   * @param: "RxData[]" will store the message which has been received, which length must between 0 and 8.
   * @retval: receive status.
   */
   /*CAN中断接受*/
   void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
  {
  	
  	if(hcan->Instance==CAN1)
  	{
  		  test = CAN_1.RxData[0]&0X03;
  			if(HAL_CAN_GetRxMessage(hcan,CAN_RX_FIFO0,&CAN_1.Rx_pHeader,CAN_1.RxData)==HAL_OK)//获取数据
  			{
  					if(CAN_1.RxData[0] == 0X02)
  					{
  							CAN_1.p_int[1]=(CAN_1.RxData[1]<<8)|CAN_1.RxData[2];
  							CAN_1.v_int[1]=(CAN_1.RxData[3]<<4)|(CAN_1.RxData[4]>>4);
  							CAN_1.t_int[1]=((CAN_1.RxData[4]&0xF)<<8)|CAN_1.RxData[5];
  							CAN_1.position[1] = uint_to_float(CAN_1.p_int[1], P_MIN, P_MAX, 16); // (-12.5,12.5)  位置
  							CAN_1.velocity[1] = uint_to_float(CAN_1.v_int[1], V_MIN, V_MAX, 12); // (-45.0,45.0)  速度
  							CAN_1.torque[1] = uint_to_float(CAN_1.t_int[1], T_MIN, T_MAX, 12); // (-18.0,18.0)    转矩
                 
  						  motor_info[1].can_id   = CAN_1.RxData[0];
  							motor_info[1].position = CAN_1.position[1];
  							motor_info[1].torque   = CAN_1.velocity[1];
  							motor_info[1].velocity = CAN_1.torque[1];						
  					} 
  				 if(CAN_1.RxData[0] == 0X13)
  				 {
  							CAN_1.p_int[2]=(CAN_1.RxData[1]<<8)|CAN_1.RxData[2];
  							CAN_1.v_int[2]=(CAN_1.RxData[3]<<4)|(CAN_1.RxData[4]>>4);
  							CAN_1.t_int[2]=((CAN_1.RxData[4]&0xF)<<8)|CAN_1.RxData[5];
  							CAN_1.position[2] = uint_to_float(CAN_1.p_int[2], P_MIN, P_MAX, 16); // (-12.5,12.5)  位置
  							CAN_1.velocity[2] = uint_to_float(CAN_1.v_int[2], V_MIN, V_MAX, 12); // (-45.0,45.0)  速度
  							CAN_1.torque[2] = uint_to_float(CAN_1.t_int[2], T_MIN, T_MAX, 12); // (-18.0,18.0)    转矩
                 
  						  motor_info[2].can_id   = CAN_1.RxData[0];
  							motor_info[2].position = CAN_1.position[2];
  							motor_info[2].torque   = CAN_1.velocity[2];
  							motor_info[2].velocity = CAN_1.torque[2];						
  					} 
  				 if(CAN_1.RxData[0] == 0X14)
  				 {
  							CAN_1.p_int[3]=(CAN_1.RxData[1]<<8)|CAN_1.RxData[2];
  							CAN_1.v_int[3]=(CAN_1.RxData[3]<<4)|(CAN_1.RxData[4]>>4);
  							CAN_1.t_int[3]=((CAN_1.RxData[4]&0xF)<<8)|CAN_1.RxData[5];
  							CAN_1.position[3] = uint_to_float(CAN_1.p_int[3], P_MIN, P_MAX, 16); // (-12.5,12.5)  位置
  							CAN_1.velocity[3] = uint_to_float(CAN_1.v_int[3], V_MIN, V_MAX, 12); // (-45.0,45.0)  速度
  							CAN_1.torque[3] = uint_to_float(CAN_1.t_int[3], T_MIN, T_MAX, 12); // (-18.0,18.0)    转矩
                 
  						  motor_info[3].can_id   = CAN_1.RxData[0];
  							motor_info[3].position = CAN_1.position[3];
  							motor_info[3].torque   = CAN_1.velocity[3];
  							motor_info[3].velocity = CAN_1.torque[3];						
  					} 
  
  	        HAL_CAN_ActivateNotification(hcan, CAN_IT_RX_FIFO0_MSG_PENDING);	//激活CAN中断通知					
  	     }
  		
    }
   	if(hcan->Instance==CAN2)
  	{
  		
  			if(HAL_CAN_GetRxMessage(hcan,CAN_RX_FIFO0,&CAN_2.Rx_pHeader,CAN_2.RxData)==HAL_OK)//获取数据
  			{
  					if(CAN_2.RxData[0] == 0X01)
  					{
  							CAN_2.p_int[0]=(CAN_2.RxData[1]<<8)|CAN_2.RxData[2];
  							CAN_2.v_int[0]=(CAN_2.RxData[3]<<4)|(CAN_2.RxData[4]>>4);
  							CAN_2.t_int[0]=((CAN_2.RxData[4]&0xF)<<8)|CAN_2.RxData[5];
  							CAN_2.position[0] = uint_to_float(CAN_2.p_int[0], P_MIN, P_MAX, 16); // (-12.5,12.5)  位置
  							CAN_2.velocity[0] = uint_to_float(CAN_2.v_int[0], V_MIN, V_MAX, 12); // (-45.0,45.0)  速度
  							CAN_2.torque[0] = uint_to_float(CAN_2.t_int[0], T_MIN, T_MAX, 12); // (-18.0,18.0)    转矩				 
  							//把信息存入电机结构体中
  							motor_info[0].can_id   = CAN_2.RxData[0];
  							motor_info[0].position = CAN_2.position[0];
  							motor_info[0].torque   = CAN_2.velocity[0];
  							motor_info[0].velocity = CAN_2.torque[0];
  					} 
  					
  				  HAL_CAN_ActivateNotification(hcan, CAN_IT_RX_FIFO0_MSG_PENDING); //激活CAN中断通知
  	   }
   }
  }
  
  
  ```

  

### Arm_task

```C
#include "stm32f4xx.h"                  // Device header
#include "Arm_Task.h" 
#include "cmsis_os.h"
#include "can.h"
#include "gpio.h"
#include "bsp_can.h"
#include "Can_user.h"
#include "Uart_user.h"
#include "Servos.h"
#include "control_data.h"

uint16_t num=0;
//电机初始化
void motor_init();
//控制数据处理
void data_operate();
//mit控制模式
void mit_contorl();
void mit_rc_contorl();

//速度位置模式控制
void vp_control();

//速度控制模式
void speed_control();

void arm_task(void const * argument)
{
		motor_init();
	  servos_init();
		for(;;)
		{		  
			data_operate();
			Speed_CtrlMotor(&motor_info[0].hcan, motor_info[0].can_id, motor_info[0].target_speed);
			HAL_Delay(1);
			Speed_CtrlMotor(&motor_info[1].hcan, motor_info[1].can_id, motor_info[1].target_speed);
			HAL_Delay(1);
			Speed_CtrlMotor(&motor_info[2].hcan, 0x03, motor_info[2].target_speed);
			HAL_Delay(1);
			Speed_CtrlMotor(&motor_info[3].hcan, 0x04, motor_info[3].target_speed);
			HAL_Delay(1);
			//osDelay(1);
		}
		osDelay(1);
		
}


//电机初始化
void motor_init()
{
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);       //开启舵机电源
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0,  GPIO_PIN_RESET);     //点个灯
	
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);     //开启电源1输出 右边
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4,  GPIO_PIN_SET);   //开启电源2输出 左边
	
	HAL_Delay(1000);	//延时1s为了给DM_MC01板可控电源电源1稳定启动
	
	motor_info[0].hcan =  hcan2;
	motor_info[1].hcan =  hcan1;
	motor_info[2].hcan =  hcan1;
	motor_info[3].hcan =  hcan1;
	
	//电机模式设置:为0为IMT模式，为1为位置速度模式，为2为速度模式
	motor_info[0].mode = 2;  
	motor_info[1].mode = 2; 
	motor_info[2].mode = 2; 
	motor_info[3].mode = 2; 
	
	//设置电机id
	motor_info[0].can_id = 0x01; 
	motor_info[1].can_id = 0x02; 
	motor_info[2].can_id = 0x03;
	motor_info[3].can_id = 0x04;


	motor_commend(motor_info[0],Data_Enable);
	HAL_Delay(2000);
	motor_commend(motor_info[1],Data_Enable);
	HAL_Delay(2000);
	motor_commend(motor_info[2],Data_Enable);
	HAL_Delay(2000);
	motor_commend(motor_info[3],Data_Enable);
	HAL_Delay(2000);
	

}
//数据处理
void data_operate()
{
	for(uint8_t i = 0;i<4;i++)
	{
			float v_float;
		  v_float = data.v_int[i];
		  motor_info[i].target_speed = v_float/127;
		  motor_info[i].target_angle = data.p_int[i];
	
	}
}


//mit控制模式
/*
	对位置进行控制时，kd 不能赋 0，否则会造成电机震荡，甚至失控
	根据 MIT 模式可以衍生出多种控制模式，如 kp=0,kd 不为 0 时，给定 v_des
	即可实现匀速转动;kp=0,kd=0，给定 t_ff 即可实现给定扭矩输出
*/
void mit_contorl()
{

	MIT_CtrlMotor(&hcan1,0x02, motor_info[1].target_angle,
														 motor_info[1].target_speed,
														 motor_info[1].Kp,
														 motor_info[1].Kd, 
														 motor_info[1].target_T_ff);
}


//速度位置模式控制
void vp_control()
{
	PosSpeed_CtrlMotor(&hcan1,motor_info[0].can_id, motor_info[0].target_angle, motor_info[0].target_speed);
}

```

