# 机械臂开发文档

## 电控部分

### 时钟树配置

![时钟树配置](..\Robot_Arm_1.0\img\时钟树配置.png)

### 蓝牙DMA接收

采用CH05蓝牙模块与控制器通信

接线如下

蓝牙模块

RX-->PC06 USART6_TX，

TX-->PC07 USART6_RX,

<img src="..\Robot_Arm_1.0\img\达妙开发板蓝牙(1).png" alt="达妙开发板蓝牙(1)" style="zoom:50%;" />



![串口6配置1](..\Robot_Arm_1.0\img\串口6配置1.png)

- Uart_user.c

```C
#include "stm32f4xx.h"                  // Device header
#include "Uart_user.h"
#include "usart.h"
#include "control_data.h"

void data_send();
void data_receive();

//串口6通信
uint8_t data_length = 17;
uint8_t rx_buffer_ch05[17];
uint8_t tx_buffer_ch05[17];

Control_Data data;


void data_receive_IT()
{
	//接受空闲中断
  
	__HAL_UART_ENABLE_IT(&huart6, UART_IT_IDLE); 
	
	HAL_UART_Receive_DMA(&huart6, rx_buffer_ch05,data_length);
  HAL_Delay(1000);
}

//串口接收中断
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{  
	if(huart->Instance==USART6)
	{	 
   //接收蓝牙模块数据包
      static uint8_t RxState=0;
		
			if(RxState==0)
      { 
           if(rx_buffer_ch05[0]==0xA5)
           {
               RxState=1;
           } 
			}
      if(RxState==1)
      {  
				//APP数据处理
				 data.x = (rx_buffer_ch05[2]<<8)|rx_buffer_ch05[1];
				 data.y = (rx_buffer_ch05[4]<<8)|rx_buffer_ch05[3];
				 data.z = (rx_buffer_ch05[6]<<8)|rx_buffer_ch05[5];
				 data.v_int[0] = (rx_buffer_ch05[8]<<8)|rx_buffer_ch05[7];
				 data.v_int[1] = (rx_buffer_ch05[10]<<8)|rx_buffer_ch05[9];
				 data.v_int[2] = (rx_buffer_ch05[12]<<8)|rx_buffer_ch05[11];
				 data.v_int[3] = (rx_buffer_ch05[14]<<8)|rx_buffer_ch05[13];
				
         RxState=2;
			}
      if(RxState==2)
      {
          if(rx_buffer_ch05[data_length-1]==0x5A)
         { 
				   RxState=0;
				 }
				 HAL_UART_Receive_DMA(&huart6,rx_buffer_ch05,data_length);
			}
		  
	}	
}
```

- control_data.h

```c
#ifndef __CONTROL_DATA_H
#define __CONTROL_DATA_H

typedef __packed struct
{
	//机械臂位置信息
  int16_t x;
	int16_t y;
	int16_t z;
	
	//速度控制
	int16_t v_int[4];     
	
	//按键信息
	int16_t key[6];       
		
} Control_Data;

extern Control_Data data;



#endif

```

### SG90舵机

因为TIM3定时器是APB1，根据时钟树可以知道其频率为84Mhz，所以设置为83和19999

计算公式如下：

![定时器计算](..\Robot_Arm_1.0\img\定时器计算.png)

![舵机PWM定时器](..\Robot_Arm_1.0\img\舵机PWM定时器.png)

- Servos.c

```C
#include "stm32f4xx.h" 
#include "Servos.h"
#include "tim.h"


void servos_init()
{
	HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_4);
}

//500 --0   1000 -- 45   1500 --90   2000 ---135  2500 --180 

void servos_control(uint16_t angle)
{
	float temp;
	temp = angle*(2500/127);
	if(temp<0)
	{
		temp=-temp;
	}
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_4, temp);
}

```

### 夹爪舵机

![夹爪舵机](..\Robot_Arm_1.0\\img\夹爪舵机.png)

### 电机can通信

- Can_User.c

```c
#include "stm32f4xx.h"                  // Device header
#include "Can_user.h"
#include "can.h"
#include "bsp_can.h"

motor_info_t motor_info[4];
 
uint8_t Data_Enable[8]     ={0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC};		//电机使能命令
uint8_t Data_Failure[8]    ={0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD};		//电机失能命令
uint8_t Data_Save_zero[8]  ={0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE};	  //电机保存零点命令
uint8_t Data_Error_clear[8]={0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB};	  //电机清除错误

//============================电机基础命令===============================================

//电机命令
/*
    Data_Enable        电机使能命令
		Data_Failure			 电机失能命令
		Data_Save_zero     电机保存零点命令
		Data_Error_clear   电机清除错误
*/
void motor_commend(motor_info_t motor,uint8_t *pData)
{
	if(motor.mode== 0)  //MIT模式
	{
		CANx_SendStdData(&hcan1,motor.can_id,pData,8);	
		HAL_Delay(10);
	}
	if(motor.mode== 1)  //位置速度模式
	{
		CANx_SendStdData(&hcan1,motor.can_id + 0x100,pData,8);	
		HAL_Delay(10);
	}
	if(motor.mode== 2) //速度模式
	{
		CANx_SendStdData(&hcan1,motor.can_id + 0x200,pData,8);	
		HAL_Delay(10);
	}
}
//============================can相关===============================================
//can滤波器
void can_filter_init(void)
{

    CAN_FilterTypeDef can_filter_st;
    can_filter_st.FilterActivation = ENABLE;
    can_filter_st.FilterMode = CAN_FILTERMODE_IDMASK;
    can_filter_st.FilterScale = CAN_FILTERSCALE_32BIT;
    can_filter_st.FilterIdHigh = 0x0000;
    can_filter_st.FilterIdLow = 0x0000;
    can_filter_st.FilterMaskIdHigh = 0x0000;
    can_filter_st.FilterMaskIdLow = 0x0000;
    can_filter_st.FilterBank = 0;
    can_filter_st.FilterFIFOAssignment = CAN_RX_FIFO0;
    HAL_CAN_ConfigFilter(&hcan1, &can_filter_st);
    HAL_CAN_Start(&hcan1);
    HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);


    can_filter_st.SlaveStartFilterBank = 14;
    can_filter_st.FilterBank = 14;
    HAL_CAN_ConfigFilter(&hcan2, &can_filter_st);
    HAL_CAN_Start(&hcan2);
    HAL_CAN_ActivateNotification(&hcan2, CAN_IT_RX_FIFO0_MSG_PENDING);
}



/**
 * @brief  发送标准ID的数据帧
 * @param  hcan     CAN的句柄
 * @param  ID       数据帧ID
 * @param  pData    数组指针
 * @param  Len      字节数0~8
 */
uint8_t CANx_SendStdData(CAN_HandleTypeDef* hcan,uint16_t ID,uint8_t *pData,uint16_t Len)
{
  static CAN_TxHeaderTypeDef   Tx_Header;
	
	Tx_Header.StdId=ID;
	Tx_Header.ExtId=0;
	Tx_Header.IDE=0;
	Tx_Header.RTR=0;
	Tx_Header.DLC=Len;
	
	
        /*找到空的发送邮箱，把数据发送出去*/
	if(HAL_CAN_AddTxMessage(hcan, &Tx_Header, pData, (uint32_t*)CAN_TX_MAILBOX0) != HAL_OK) //
	{
		if(HAL_CAN_AddTxMessage(hcan, &Tx_Header, pData, (uint32_t*)CAN_TX_MAILBOX1) != HAL_OK)
		{
			HAL_CAN_AddTxMessage(hcan, &Tx_Header, pData, (uint32_t*)CAN_TX_MAILBOX2);
        }
    }
    return 0;
}

//======================================================================================


```

## MATLAB仿真

### 机器人工具箱



在网站www.petercorke.com下载机器人工具箱

```
>> rtbdemo
```

#### 建立机器人模型

根据机械臂实物，建立DH表

![建立DH表](..\Robot_Arm_1.0\img\建立DH表.png)

然后在机器人工具箱中实现

```MATLAB
%% OUR_Manipulator
%机械臂建模
clear;
clc;
% DH表
theta1 = 0; D1 = 0;   A1 = 0;    alpha1 = -pi/2;  offset1 = 0;
theta2 = 0; D2 = 0;   A2 = 250;  alpha2 = 0;      offset2 = -pi/2;
theta3 = 0; D3 = 0;   A3 = 250;  alpha3 = 0;      offset3 = pi/2;
theta4 = 0; D4 = 0;   A4 = 0;    alpha4 = -pi/2;  offset4 = 0;
theta5 = 0; D5 = 0;   A5 = 0;    alpha5 = 0;      offset5 = 0;
% 创建关节


L(1) = Link('revolute','d',D1,'a',A1,'alpha', alpha1,'offset', offset1);
L(2) = Link('revolute','d',D2,'a',A2,'alpha', alpha2,'offset', offset2);
L(3) = Link('revolute','d',D3,'a',A3,'alpha', alpha3,'offset', offset3);
L(4) = Link('revolute','d',D4,'a',A4,'alpha', alpha4,'offset', offset4);
L(5) = Link('revolute','d',D5,'a',A5,'alpha', alpha5,'offset', offset5);
Five_dof=SerialLink(L,'name','5-dof');

% 关节角度限制
L(1).qlim = [-150,150]/180 * pi;
L(2).qlim = [-70,90] /180 * pi;
L(3).qlim = [-70,10]  /180 * pi;
L(4).qlim = [-90,90]/180 * pi;
L(5).qlim = [-180,180]/180 * pi;

%查看DH表
Five_dof.display();

%查看GUI
Five_dof.teach   

%% 输出DH表
robot:: 5 axis, RRRRR, modDH, slowRNE                            
+---+-----------+-----------+-----------+-----------+-----------+
| j |     theta |         d |         a |     alpha |    offset |
+---+-----------+-----------+-----------+-----------+-----------+
|  1|         q1|         63|          0|          0|          0|
|  2|         q2|          0|          0|     1.5708|     1.5708|
|  3|         q3|          0|        250|          0|     1.5708|
|  4|         q4|          0|        250|          0|    -1.5708|
|  5|         q5|        116|          0|    -1.5708|          0|
+---+-----------+-----------+-----------+-----------+-----------+

```

![manipulator](..\Robot_Arm_1.0\img\manipulator.bmp)	

设置初始角度

```MATLAB
q1 = [0,0,0,pi/2,0];
robot.plot(q1)
```

![manipulator](..\Robot_Arm_1.0\img\manipulator_reset.bmp)

#### 常用函数

```matlab
%% 旋转-->旋转矩阵
clear;
clc;
%Eular Angle
T1 = eul2tr(90,60,30) 
T2 = trotz(90)*troty(60)*trotz(30)
%Fixed Angle
T3 = rpy2tr(90,60,30)
T4 = trotz(30)*troty(60)*trotx(90)


%% 位移-->变换矩阵
T  =  transl(1.5,1,0.5)*trotx(30)*trotz(60) %get a transformation matrix
P  =  transl(T)  % get P from T
R  =  t2r(T)     % get R from T
T1 =  r2t(R)     % get T from R 

Five_dof.teach  %示教

q = [0,0,0,0,0] %机械臂参数初始化
Five_dof.plot(q)

%fkine 正向运动学
q0 = [pi/2 pi/2 0 0 0];
T = Five_dof.fkine(q0)

%fkine 逆向运动学
q1 = Five_dof.ikine(T,'mask',[1 1 1 1 1 0])
q2 = Five_dof.ikunc(T)
```

#### 机械臂工作空间可视化

```MATLAB
%% 机械臂工作空间可视化
% 关节空间随机生成变量--(fkine)-->变换矩阵--(transl)-->三维坐标
% rand() 在[0,1]中随机生成一个数
% 随机关节空间变量 q = qmin+rand(qmax-qmin)

% 定义关节限制Link.qlim
%主要限制前三个关节
L(1).qlim = [-2,2];
L(2).qlim = [-1,1];
L(3).qlim = [-1.67,0.9];

L(4).qlim = [-90,90]/180 * pi;
L(5).qlim = [-180,180]/180 * pi;

% 在空间中绘制点
num = 20000;
for i = 1:num

    q1 = L(1).qlim(1) + rand*(L(1).qlim(2) - L(1).qlim(1));
    q2 = L(2).qlim(1) + rand*(L(2).qlim(2) - L(2).qlim(1));
    q3 = L(3).qlim(1) + rand*(L(3).qlim(2) - L(3).qlim(1));
    q4 = L(4).qlim(1) + rand*(L(4).qlim(2) - L(4).qlim(1));
    q5 = L(5).qlim(1) + rand*(L(5).qlim(2) - L(5).qlim(1));
    
    q = [q1 q2 q3 q4 q5];

    T = Five_dof.fkine(q);

    P(i,:) = transl(T);

end
plot3(P(:,1),P(:,2),P(:,3),'b.','MarkerSize',1);
```

整体代码

```matlab
%% 机械臂工作空间可视化
num = 40000;
for i = 1:num

    q1 = L(1).qlim(1) + rand*(L(1).qlim(2) - L(1).qlim(1));
    q2 = L(2).qlim(1) + rand*(L(2).qlim(2) - L(2).qlim(1));
    q3 = L(3).qlim(1) + rand*(L(3).qlim(2) - L(3).qlim(1));
    q4 = L(4).qlim(1) + rand*(L(4).qlim(2) - L(4).qlim(1));
    q5 = L(5).qlim(1) + rand*(L(5).qlim(2) - L(5).qlim(1));
    
    q = [q1 q2 q3 q4 q5];
    T = Five_dof.fkine(q);
    %Five_dof.plot(q);
    P(i,:) = transl(T);  
end

plot3(P(:,1),P(:,2),P(:,3),'b.','MarkerSize',1);

Five_dof.display();  %查看DH表
Five_dof.teach       %查看GUI
```

![workspace](..\Robot_Arm_1.0\\img\机械臂工作空间1.bmp)
![workspace](..\Robot_Arm_1.0\\img\机械臂工作空间2.bmp)
![workspace](..\Robot_Arm_1.0\\img\机械臂工作空间3.bmp)

#### 轨迹规划

```MATLAB
%% 轨迹绘制
%给定位置：(-580,45,22) --> (75,-460,0) 
P1 = [-580,45,22];
P2 = [75,-460,0];

t = linspace(0,2,51);
Traj=mtraj(@tpoly,P1,P2,t);

n = size(Traj,1);
T = zeros(4,4,n);

for i = 1:n
    T(:,:, i) = transl(Traj(i,:))*troty(180);
end

Qtraj = Five_dof.ikunc(T);

%Five_dof.plot(Qtraj);  %仅有演示
%Five_dof.plot(Qtraj,'trail','b'); %留下轨迹
Five_dof.plot(Qtraj,'movie','test.gif'); %留下轨迹
```

![traj](..\Robot_Arm_1.0\\img\traj.bmp)



![trail](..\Robot_Arm_1.0\img\trail.gif)

输出轨迹变化曲线

```MATLAB
%%
hold on

plot(t,Traj(:,1),'.-','LineWidth',1);
plot(t,Traj(:,2),'.-','LineWidth',1);
plot(t,Traj(:,3),'.-','LineWidth',1);

grid on
legend('x','y','z');
xlabel('time');
ylabel('position')
```

![sss](..\Robot_Arm_1.0\\img\sss.bmp)

### 代码实现

参考文章[【MATLAB】5DOFs机械臂运动学正逆解（MDH）-解析法实现_5dof机械臂的逆解有多少-CSDN博客](https://blog.csdn.net/qq_43557907/article/details/122707124)

[协作机器人零力控制与碰撞检测技术研究 - 中国知网 (cnki.net)](https://kns.cnki.net/kcms2/article/abstract?v=vRsBqZf6HxjZ9BlY5oODBw9M817Mkui0lsxQaVzEZ9HS69p5B6Xs_ztjOrC6TiibU_bNZacbORFoD1qCV4bkqUoS9ppf9DHa921u6_Hg-PR92TBADv9c8dbOp781Ej5qZ9JggafDrE8_MysOuFeLlQ==&uniplatform=NZKPT&language=CHS)

#### 正运动学FK

![运动学FK](..\Robot_Arm_1.0\img\运动学FK.png)

```MATLAB
%设置theta
theta1 =  0;    
theta2 =  0;    
theta3 =  0;    
theta4 =  0;    
theta5 =  0; 

T01 = [cos(theta1) -cos(alpha1)*sin(theta1)  sin(alpha1)*sin(theta1) a1*cos(theta1);
       sin(theta1)  cos(alpha1)*cos(theta1) -sin(alpha1)*cos(theta1) a1*sin(theta1);
       0            sin(alpha1)              cos(alpha1)             d1;
       0            0                        0                       1]

%theta的计算要添加在这里
T12 = [cos(theta2+pi/2) -cos(alpha2)*sin(theta2+pi/2)  sin(alpha2)*sin(theta2+pi/2) a2*cos(theta2+pi/2);
       sin(theta2+pi/2)  cos(alpha2)*cos(theta2+pi/2) -sin(alpha2)*cos(theta2+pi/2) a2*sin(theta2+pi/2);
       0                 sin(alpha2)                  cos(alpha2)                   d2;
       0                 0                            0                             1]

T23 = [cos(theta3+pi/2) -cos(alpha3)*sin(theta3+pi/2)  sin(alpha3)*sin(theta3+pi/2) a3*cos(theta3+pi/2);
       sin(theta3+pi/2)  cos(alpha3)*cos(theta3+pi/2) -sin(alpha3)*cos(theta3+pi/2) a3*sin(theta3+pi/2);
       0                 sin(alpha3)                   cos(alpha3)                  d3;
       0                 0                             0                            1]
  
T34 = [cos(theta4) -cos(alpha4)*sin(theta4)  sin(alpha4)*sin(theta4) a4*cos(theta4);
       sin(theta4)  cos(alpha4)*cos(theta4) -sin(alpha4)*cos(theta4) a4*sin(theta4);
       0            sin(alpha4)              cos(alpha4)             d4;
       0            0                        0                       1]
T45 = [cos(theta5) -cos(alpha5)*sin(theta5)  sin(alpha5)*sin(theta5) a5*cos(theta5);
       sin(theta5)  cos(alpha5)*cos(theta5) -sin(alpha5)*cos(theta5) a5*sin(theta5);
       0            sin(alpha5)              cos(alpha5)             d5;
       0            0                        0                       1]

T05 = T01*T12*T23*T34*T45 %最终的T矩阵

qi = Five_dof.ikunc(T05)  %验证角度是否正确
q0 = [theta1 theta2 theta3 theta4 theta5]
T = Five_dof.fkine(q0)    %与机器人工具箱得出的结论进行对比
```

经过对比验证，结果完全一致(T05为计算结果，T为函数计算结果)

![FK验证](..\Robot_Arm_1.0\img\FK验证.png)

计算过程中出现的BUG

```matlab
%% 当直接使用时，会出现计算结果为4967757600021511
>>cos（pi/2）
>>ans = 4967757600021511
%要用
```

手稿

![机械臂正解](..\Robot_Arm_1.0\img\正解.png)

最后将正运动学封装成函数

非常怪的bug，对theta2操作，就会出错？八嘎，原来是把s2写成c2了

```matlab
%% 函数定义
theta = [0 pi/2 0 0 0];
a =     [0 250 250 0 0];
d =     [0 0 0 0 0];
T = FK_calc(theta,d,a)

function Get_T05 = FK_calc(theta,d,a)
c1 = cos(theta(1));c2 = cos(theta(2)-pi/2);c3 = cos(theta(3)+pi/2);c4 = cos(theta(4));c5 = cos(theta(5));
s1 = sin(theta(1));s2 = sin(theta(2)-pi/2);s3 = sin(theta(3)+pi/2);s4 = sin(theta(4));s5 = sin(theta(5));
a1 = a(1);a2 = a(2);a3 = a(3);a4 = a(4);a5 = a(5);
d1 = d(1);d2 = d(2);d3 = d(3);d4 = d(4);d5 = d(5);

r11 = c5*(c4*(c1*c2*c3-c1*s2*s3)-s4*(c1*c2*s3+c1*c3*s2))+s1*s5;%
r21 = c5*(c4*(c2*c3*s1-s1*s2*s3)-s4*(c2*s1*s3+c3*s1*s2))-c1*s5;%
r31 = -c5*(c4*(c2*s3+c3*s2)+s4*(c2*c3-s2*s3));%

r12 =  c5*s1-s5*(c4*(c1*c2*c3-c1*s2*s3)-s4*(c1*c2*s3+c1*c3*s2));
r22 = -c1*c5-s5*(c4*(s1*c2*c3-s1*s2*s3)-s4*(c2*s1*s3+c3*s1*s2));
r32 = s5*(c4*(c2*s3+s2*c3)+s4*(c2*c3-s2*s3));
 
r13 = -c4*(c1*c2*s3+c1*c3*s2)-s4*(c1*c2*c3-c1*s2*s3);
r23 = -c4*(c2*s1*s3+c3*s1*s2)-s4*(s1*c2*c3-s1*s2*s3);
r33 = -c4*(c2*c3-s2*s3)+s4*(c2*s3+c3*s2);

px =   a2*c1*c2 + a3*c1*c2*c3 - a3*c1*s2*s3;
py =   a2*c2*s1 + a3*c2*c3*s1 - a3*s1*s2*s3;
pz =  -a2*s2    - a3*c2*s3    - a3*c3*s2;

Get_T05 = [r11 r12 r13 px;r21 r22 r23 py ;r31 r32 r33 pz;0 0 0 1];
end

```

![函数验证](C:..\Robot_Arm_1.0\img\函数验证.png)

可见结果正确

#### 逆运动学IK

##### 具体思路

![逆矩阵](..\Robot_Arm_1.0\img\逆矩阵.png)

![机械臂逆解](..\Robot_Arm_1.0\img\机械臂逆解.png)

![机械臂逆解2](..\Robot_Arm_1.0\img\机械臂逆解2.png)

#### 轨迹规划

![路径规划](..\Robot_Arm_1.0\img\路径规划.png)

##### 单个电机

```matlab
% 轨迹规划函数 两点之间确定一条轨迹===========================================
function res = a_path_calc(theta,v,a,t)

% 起始角度和终止角度
q0     = theta(1)
qf     = theta(2)
dq0    = v(1);
dqf    = v(2);
ddq0   = a(1);
ddqf   = a(2);
ts     = t(1);
tf     = t(2);
% 路径规划公式
%q0   = theta0   = c0
%qf   = thetaf   = c0 + c1*tf +c2*tf^2 +c3*tf^3 + c4*tf^4 + c5*tf^5
%dq0  = dtheta0  = c1
%dqf  = dthetaf  = c1 + 2*c2*tf + 3*c3*tf^2 + 4*c4*tf^3 + 5*c5*tf^4
%ddq0 = ddtheta0 = 2*c2 
%ddqf = ddthetaf = 2*c2 + 6*c3*tf +12*c4*tf^2 +20*c5*tf^3

% 由路径规划公式推出下面计算多项式的各项系数
% 计算五次多项式
c0 = q0
c1 = dq0
c2 = ddq0/2
c3 = (20*(qf-q0)-( 8*dqf + 12*dq0)*(tf-ts) - (3*ddq0 -   ddqf)*(tf-ts)^2)/(2*(tf-ts)^3)
c4 = (30*(q0-qf)+(14*dqf + 16*dq0)*(tf-ts) + (3*ddq0 - 2*ddqf)*(tf-ts)^2)/(2*(tf-ts)^4)
c5 = (12*(qf-q0)-( 6*dqf +  6*dq0)*(tf-ts) - (  ddq0 -   ddqf)*(tf-ts)^2)/(2*(tf-ts)^5)

%获得公式
t = ts:0.1:tf;
%1 角度  五次多项式
theta =c0+c1*power((t-ts),1)+c2*power((t-ts),2)+c3*power((t-ts),3)+c4*power((t-ts),4)+c5*power((t-ts),5);
%2 速度  五次多项式
vel   =c1+2*c2*power((t-ts),1)+3*c3*power((t-ts),2)+4*c4*power((t-ts),3)+5*c5*power((t-ts),4);
%3 加速度五次多项式
acc   =2*c2+6*c3*power((t-ts),1)+12*c4*power((t-ts),2)+20*c5*power((t-ts),3);

% 绘制theta路径曲线
subplot(3,1,1)
plot(t,theta,'r','linewidth',2)
ylabel('position')
grid on
hold on;
% 绘制vel速度曲线
subplot(3,1,2)
plot(t,vel,'g','linewidth',2)
ylabel('velocity')
grid on
hold on;
%绘制加速度曲线
subplot(3,1,3)
plot(t,acc,'b','linewidth',2)
ylabel('acceleration')
grid on
hold on;

res = [theta vel acc];
end
```

##### 整体路径规划

所有关节电机同时工作

```matlab

% 整体路径规划 根据起始角度和终止角度得出5个轴的运动轨迹
function path = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t)

% 起始角度和终止角度
q1_s = theta_start(1);q1_f = theta_final(1);
q2_s = theta_start(2);q2_f = theta_final(2);
q3_s = theta_start(3);q3_f = theta_final(3);
q4_s = theta_start(4);q4_f = theta_final(4);
q5_s = theta_start(5);q5_f = theta_final(5);

%起始速度和最终速度
v1_s = v_s(1) ; v1_f = v_f(1);
v2_s = v_s(2) ; v2_f = v_f(2);
v3_s = v_s(3) ; v3_f = v_f(3);
v4_s = v_s(4) ; v4_f = v_f(4);
v5_s = v_s(5) ; v5_f = v_f(5);

%起始加速度和最终加速度
a1_s = a_s(1) ; a1_f = a_f(1);
a2_s = a_s(2) ; a2_f = a_f(2);
a3_s = a_s(3) ; a3_f = a_f(3);
a4_s = a_s(4) ; a4_f = a_f(4);
a5_s = a_s(5) ; a5_f = a_f(5);

% 每个轴的轨迹
motor1 = a_path_calc([q1_s,q1_f],[v1_s,v1_f],[a1_s,a1_f],t);
motor2 = a_path_calc([q2_s,q2_f],[v2_s,v2_f],[a2_s,a2_f],t);
motor3 = a_path_calc([q3_s,q3_f],[v3_s,v3_f],[a3_s,a3_f],t);
motor4 = a_path_calc([q4_s,q4_f],[v4_s,v4_f],[a4_s,a4_f],t);
motor5 = a_path_calc([q5_s,q5_f],[v5_s,v5_f],[a5_s,a5_f],t);

%画图
t = t(1):0.1:t(2);
% 绘制motor1路径曲线
subplot(3,2,1)
ylabel('motor1')
plot(t,motor1(1,:),'r','linewidth',2)
hold on;
plot(t,motor1(2,:),'g','linewidth',2)
hold on;
plot(t,motor1(3,:),'b','linewidth',2)
grid on;
hold on;

% 绘制motor2路径曲线
subplot(3,2,2)
ylabel('motor2')
plot(t,motor2(1,:),'r','linewidth',2)
hold on;
plot(t,motor2(2,:),'g','linewidth',2)
hold on;
plot(t,motor2(3,:),'b','linewidth',2)
grid on;
hold on;


% 绘制motor3路径曲线
subplot(3,2,3)
ylabel('motor3')
plot(t,motor3(1,:),'r','linewidth',2)
hold on;
plot(t,motor3(2,:),'g','linewidth',2)
hold on;
plot(t,motor3(3,:),'b','linewidth',2)
grid on;
hold on;

% 绘制motor4路径曲线
subplot(3,2,4)
ylabel('motor4')
plot(t,motor4(1,:),'r','linewidth',2)
hold on;
plot(t,motor4(2,:),'g','linewidth',2)
hold on;
plot(t,motor4(3,:),'b','linewidth',2)
grid on;
hold on;

% 绘制motor5路径曲线
subplot(3,2,5)
ylabel('motor5')
plot(t,motor5(1,:),'r','linewidth',2)
hold on;
plot(t,motor5(2,:),'g','linewidth',2)
hold on;
plot(t,motor5(3,:),'b','linewidth',2)
grid on;
hold on;



path = [motor1;motor2;motor3;motor4;motor5];

end

```

调用示例

```matlab
theta_start = [0 0 0 0 0];
theta_final = [45 180 90 0 23];
v_s = [0 0 0 0 0];
v_f = [0 0 0 0 0];
a_s = [0 0 0 0 0];
a_f = [0 0 0 0 0];
t   = [0 10];

path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);

theta_start = [45 180 90 0 23];
theta_final = [90 180 120 20 73];
v_s = [0 0 0 0 0];
v_f = [0 0 0 0 0];
a_s = [0 0 0 0 0];
a_f = [0 0 0 0 0];
t   = [10 20];
path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);
```

![轨迹规划仿真](..\Robot_Arm_1.0\img\轨迹规划仿真.png)

查看机械臂跟随轨迹运动

```C
theta_start = [0 0 0 0 0];
theta_final = [pi/2 pi/6 pi/7 -pi/2 0];
v_s = [0 0 0 0 0];
v_f = [0 0 0 0 0];
a_s = [0 0 0 0 0];
a_f = [0 0 0 0 0];
t   = [0 10];

T = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);
q1 = T.motor1.theta
q2 = T.motor2.theta
q3 = T.motor3.theta
q4 = T.motor4.theta
q5 = T.motor5.theta

%轨迹规划仿真
num = 1;
for i = 1:numel(q1)-1
    B = [q1(num) q2(num) q3(num) q4(num) q5(num)]
    num = num+1
    subplot(3,2,6)
    Five_dof.plot(B)
end
```

![机械臂轨迹仿真](..\Robot_Arm_1.0\img\机械臂轨迹仿真.png)

##### 轨迹规划仿真

```MATLAB
%% draft
theta_start = [0 0 0 0 0];
theta_final = [pi/2 pi/6 pi/7 -pi/2 0];
v_s = [0 0 0 0 0];
v_f = [0 0 0 0 0];
a_s = [0 0 0 0 0];
a_f = [0 0 0 0 0];
t   = [0 10];

T = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);
q1 = T.motor1.theta
q2 = T.motor2.theta
q3 = T.motor3.theta
q4 = T.motor4.theta
q5 = T.motor5.theta

%轨迹规划仿真
num = 1;
for i = 1:numel(q1)-1
    B = [q1(num) q2(num) q3(num) q4(num) q5(num)]
    num = num+1
    subplot(3,2,6)
    Five_dof.plot(B)
end
```

#### 函数封装！

###### FK.m

```matlab
function [T0_tool] = FK(Angle_T,a,d,alpha,l)
syms thetas as ds al
%传入角度
theta1 = Angle_T(1, 1);
theta2 = Angle_T(1, 2);
theta3 = Angle_T(1, 3);
theta4 = Angle_T(1, 4);
theta5 = Angle_T(1, 5);

d1 = d(1); d2 = d(2); d3 = d(3); d4 = d(4); d5 = d(5); 
a1 = a(1); a2 = a(2); a3 = a(3); a4 = a(4); a5 = a(5); 
alpha1 = alpha(1); alpha2 = alpha(2); alpha3 = alpha(3); 
alpha4 = alpha(4); alpha5 = alpha(5); 


Ti_1i = [      cos(thetas)           -sin(thetas)           0              as;
       sin(thetas)*cos(al)    cos(thetas)*cos(al)    -sin(al)     -sin(al)*ds;
       sin(thetas)*sin(al)    cos(thetas)*sin(al)     cos(al)      cos(al)*ds;
                         0                     0            0               1];
% 需要修改偏置
%subs将Ti_1i中的变量[thetas ...]替换成[theta1 ...]
%double转为双精度浮点数
T01 = subs(Ti_1i, [thetas al as ds],[theta1 alpha1 a1 d1]);
T12 = subs(Ti_1i, [thetas al as ds],[theta2+pi/2 alpha2 a2 d2]);
T23 = subs(Ti_1i, [thetas al as ds],[theta3+pi/2 alpha3 a3 d3]);
T34 = subs(Ti_1i, [thetas al as ds],[theta4-pi/2 alpha4 a4 d4]);
T45 = double(subs(Ti_1i, [thetas al as ds],[theta5 alpha5 a5 d5]));
T5_tool = transl(0,0,l); %执行器tool的位移

T0_tool = double(T01*T12*T23*T34*T45*T5_tool); %从基坐标系到工具坐标系
end

```

###### IK.m

```matlab
function  theta = IK(T0_tool,a,d,l)
    
    % 机械臂坐标系到机器人执行器坐标系的矩阵
    r11 = T0_tool(1, 1); r21 = T0_tool(2, 1); r31 = T0_tool(3, 1);
    r12 = T0_tool(1, 2); r22 = T0_tool(2, 2); r32 = T0_tool(3, 2);
    r13 = T0_tool(1, 3); r23 = T0_tool(2, 3); r33 = T0_tool(3, 3);
    px =  T0_tool(1, 4); py =  T0_tool(2, 4); pz =  T0_tool(3, 4);
    
    % 机械臂参数
    d1 = d(1); d2 = d(2); d3 = d(3); d4 = d(4); d5 = d(5); 
    a1 = a(1); a2 = a(2); a3 = a(3); a4 = a(4); a5 = a(5);  
   

    %% theta1 两个解
    theta1 = zeros(1,2);

    theta1(1,1) = antiSinCos(py,px);
    theta1(1,2) = antiSinCos(-py,-px);

    
    %% theta5 
    theta5 = zeros(1,2);
    theta5(1,1) = antiSinCos(r21*cos(theta1(1,1))-r11*sin(theta1(1,1)),r22*cos(theta1(1,1))-r12*sin(theta1(1,1)));
    theta5(2,1) = antiSinCos(r21*cos(theta1(1,2))-r11*sin(theta1(1,2)),r22*cos(theta1(1,2))-r12*sin(theta1(1,2)));
    sins = r21*cos(theta1(1,1))-r11*sin(theta1(1,1))
    coss = r22*cos(theta1(1,1))-r12*sin(theta1(1,1))
    theta5

    % 储存数据：生成一个[theta5(1,1),theta5(1,2),theta5(1,1),theta5(2,2)]的行
    theta5_use = [theta5(1,1),theta5(2,1)];
    theta5 = repmat(theta5_use,1,2);

    %% theta3
    theta3 = zeros(2,2);
    for i =1:2
        x = px*cos(theta1(i)) - d5*(r13*cos(theta1(i)) + r23*sin(theta1(i))) + py*sin(theta1(i));
        y = pz - d1 - d5*r33;
        
        te = (x.^2+y.^2-a4.^2-a3.^2)/(2*a3*a4)
        %如果abs(sin)的值大于1,立即推放弃这个解；其余情况剩下两个解
        if (x.^2+y.^2-a4.^2-a3.^2)/(2*a3*a4)>1 || (x.^2+y.^2-a4.^2-a3.^2)/(2*a3*a4)<-1
            theta3(1,i) = inf;
            theta3(2,i) = inf;
        else
            theta3(1,i) = asin(-(x.^2+y.^2-a4.^2-a3.^2)/(2*a3*a4));
            theta3(2,i) = pi- asin(-(x.^2+y.^2-a4.^2-a3.^2)/(2*a3*a4)) ;
        end
     
    end

    %排成一行
    theta3 = [theta3(1,:),theta3(2,:)]
   
    %越界判断
    for i =1:4
        if theta3(i)>3.14
            theta3(i) = theta3(i) - 2*pi;
        elseif theta3(i)<-3.14
            theta3(i) = theta3(i) + 2*pi;
        end
    end
    %% theta2
    theta2 = zeros(1,4);
    theta1 = reshape(repmat(theta1,1,2),1,[]);

    for i =1:4  
        x = px*cos(theta1(i)) - d5*(r13*cos(theta1(i)) + r23*sin(theta1(i))) + py*sin(theta1(i));
        y = pz - d1 - d5*r33;

        r = [-a4*cos(theta3(i))       a4*sin(theta3(i))-a3;
             -a4*sin(theta3(i))+a3   -a4*cos(theta3(i))];
        if theta3(i) < 10^10 % 判断theta3是否有解
              %解方程
              %注意,在这里解方程的时候不要用symply()对矩阵化简，这样会少一个组解
              sc2(1) =  - ((a3 - a4*sin(theta3(i)))*(d1 - pz + d5*r33))/(a4^2*cos(theta3(i))^2 + a4^2*sin(theta3(i))^2 + a3^2 - 2*a3*a4*sin(theta3(i))) - (a4*cos(theta3(i))*(px*cos(theta1(i)) - d5*(r13*cos(theta1(i)) + r23*sin(theta1(i))) + py*sin(theta1(i))))/(a4^2*cos(theta3(i))^2 + a4^2*sin(theta3(i))^2 + a3^2 - 2*a3*a4*sin(theta3(i)))
              sc2(2) =    (a4*cos(theta3(i))*(d1 - pz + d5*r33))/(a4^2*cos(theta3(i))^2 + a4^2*sin(theta3(i))^2 + a3^2 - 2*a3*a4*sin(theta3(i))) - ((a3 - a4*sin(theta3(i)))*(px*cos(theta1(i)) - d5*(r13*cos(theta1(i)) + r23*sin(theta1(i))) + py*sin(theta1(i))))/(a4^2*cos(theta3(i))^2 + a4^2*sin(theta3(i))^2 + a3^2 - 2*a3*a4*sin(theta3(i)))

              if sc2(1)>1 || sc2(2)>1 || sc2(1)<-1 || sc2(2)<-1
                theta2(i) = inf;
            else
                theta2(i) = antiSinCos(sc2(2),sc2(1));
            end
        else %theta3无解则theta2也无解
            theta2(i) = inf;
        end
    end

    %越界判断
    for i =1:4
        if theta2(i)>3.14
            theta2(i) = theta2(i) - 2*pi;
        elseif theta2(i)<-3.14
            theta2(i) = theta2(i) + 2*pi;
        end
    end

    %% theta4
    theta(1,:) = theta1;
    theta(2,:) = theta2;
    theta(3,:) = theta3;
    theta(5,:) = theta5;

    for i =1:4
        c = r31*cos(theta(5,i)) - r32*sin(theta(5,i))
        s = r11*cos(theta(1,i))*cos(theta(5,i)) - r12*cos(theta(1,i))*sin(theta(5,i)) + r21*cos(theta(5,i))*sin(theta(1,i)) - r22*sin(theta(1,i))*sin(theta(5,i))
        theta(4,i) = antiSinCos(-s,c)-theta(2,i)-theta(3,i);
        
        % 越界判断
        if theta(4,i)>3.14
            theta(4,i) = theta(4,i) - 2*pi;
        elseif theta(4,i)<-3.14
            theta(4,i) = theta(4,i) + 2*pi;
        end
    end

    theta = theta';
```

###### path_calc.m

```matlab
% 整体路径规划 根据起始角度和终止角度得出5个轴的运动轨迹
function path = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t)

% 起始角度和终止角度
q1_s = theta_start(1);q1_f = theta_final(1);
q2_s = theta_start(2);q2_f = theta_final(2);
q3_s = theta_start(3);q3_f = theta_final(3);
q4_s = theta_start(4);q4_f = theta_final(4);
q5_s = theta_start(5);q5_f = theta_final(5);

%起始速度和最终速度
v1_s = v_s(1) ; v1_f = v_f(1);
v2_s = v_s(2) ; v2_f = v_f(2);
v3_s = v_s(3) ; v3_f = v_f(3);
v4_s = v_s(4) ; v4_f = v_f(4);
v5_s = v_s(5) ; v5_f = v_f(5);

%起始加速度和最终加速度
a1_s = a_s(1) ; a1_f = a_f(1);
a2_s = a_s(2) ; a2_f = a_f(2);
a3_s = a_s(3) ; a3_f = a_f(3);
a4_s = a_s(4) ; a4_f = a_f(4);
a5_s = a_s(5) ; a5_f = a_f(5);

% 每个轴的轨迹
motor1 = a_path_calc([q1_s,q1_f],[v1_s,v1_f],[a1_s,a1_f],t);
motor2 = a_path_calc([q2_s,q2_f],[v2_s,v2_f],[a2_s,a2_f],t);
motor3 = a_path_calc([q3_s,q3_f],[v3_s,v3_f],[a3_s,a3_f],t);
motor4 = a_path_calc([q4_s,q4_f],[v4_s,v4_f],[a4_s,a4_f],t);
motor5 = a_path_calc([q5_s,q5_f],[v5_s,v5_f],[a5_s,a5_f],t);


%传回结构体
res.motor1 = motor1;
res.motor2 = motor2;
res.motor3 = motor3;
res.motor4 = motor4;
res.motor5 = motor5;

path = res;

end



% 轨迹规划函数 两点之间确定一条直线===========================================
function res = a_path_calc(theta,v,a,t)

% 起始角度和终止角度
q0     = theta(1);
qf     = theta(2);
dq0    = v(1);
dqf    = v(2);
ddq0   = a(1);
ddqf   = a(2);
ts     = t(1);
tf     = t(2);
% 路径规划公式
%q0   = theta0   = c0
%qf   = thetaf   = c0 + c1*tf +c2*tf^2 +c3*tf^3 + c4*tf^4 + c5*tf^5
%dq0  = dtheta0  = c1
%dqf  = dthetaf  = c1 + 2*c2*tf + 3*c3*tf^2 + 4*c4*tf^3 + 5*c5*tf^4
%ddq0 = ddtheta0 = 2*c2 
%ddqf = ddthetaf = 2*c2 + 6*c3*tf +12*c4*tf^2 +20*c5*tf^3

% 由路径规划公式推出下面计算多项式的各项系数
% 计算五次多项式
c0 = q0;
c1 = dq0;
c2 = ddq0/2;
c3 = (20*(qf-q0)-( 8*dqf + 12*dq0)*(tf-ts) - (3*ddq0 -   ddqf)*(tf-ts)^2)/(2*(tf-ts)^3);
c4 = (30*(q0-qf)+(14*dqf + 16*dq0)*(tf-ts) + (3*ddq0 - 2*ddqf)*(tf-ts)^2)/(2*(tf-ts)^4);
c5 = (12*(qf-q0)-( 6*dqf +  6*dq0)*(tf-ts) - (  ddq0 -   ddqf)*(tf-ts)^2)/(2*(tf-ts)^5);

%获得公式
t = ts:0.1:tf;
%1 角度  五次多项式
theta =c0+c1*power((t-ts),1)+c2*power((t-ts),2)+c3*power((t-ts),3)+c4*power((t-ts),4)+c5*power((t-ts),5)
%2 速度  五次多项式
vel   =c1+2*c2*power((t-ts),1)+3*c3*power((t-ts),2)+4*c4*power((t-ts),3)+5*c5*power((t-ts),4);
%3 加速度五次多项式
acc   =2*c2+6*c3*power((t-ts),1)+12*c4*power((t-ts),2)+20*c5*power((t-ts),3)


motor.theta = theta;
motor.vel   = vel;
motor.acc   = acc;

res = motor;
end

```

###### target_calc.m

![工具坐标系](..\Robot_Arm_1.0\img\工具坐标系.png)

```matlab
%将输入的x，y，z坐标转换为FK矩阵
function T_target = target_calc(x,y,z)

 %物体相对于机械臂底座的位置
 T_objection = [1 0 0 x; 0 1 0 y; 0 0 1 0; 0 0 0 1];
 %执行器相对于机械臂末端的矩阵
 T_tool      = [0 1 0 0; 1 0 0 0; 0 0 -1 z+63; 0 0 0 1];

  
 T_target = T_objection * T_tool;
end
```

###### antisincos.m

```matlab
%用来求arctan的函数
function angle = antiSinCos(sA,cA)
    eps = 1e-8;
    angle = 0;
    
    %abs(cos) = 0 和abs(sin) = 0 的时候，让theta = 0；
    if(abs(sA) < eps) && (abs(cA) < eps)
        return ;
    end
    
    %abs(cos) = 0 的时候，让theta = 90 *（sin的符号）
    if abs(cA) < eps   
        angle = pi/2.0*sign(sA);

    %abs(cos = 0 的时候，让theta = 0     
    elseif abs(sA) < eps
%         if sign(cA) == 1
%             return ;
%         else
%             angle = pi;
%             return ;
%         end   
    else
        angle = atan2(sA, cA);
    end

end
```

###### main.m

```matlab
clc;clear;close all
% 设置角度单位转换
degtorad = pi/180;

l = 0;

% 改进型DH表
theta1 = 0; d1 = 63;  a1 = 0;    alpha1 =   0 * degtorad;   
theta2 = 0; d2 = 0;   a2 = 0;    alpha2 =  90 * degtorad;  
theta3 = 0; d3 = 0;   a3 = 250;  alpha3 =   0 * degtorad;  
theta4 = 0; d4 = 0;   a4 = 250;  alpha4 =   0 * degtorad; 
theta5 = 0; d5 = 116; a5 = 0;    alpha5 = -90 * degtorad;

% 设置连杆偏距
d = [d1,d2,d3,d4,d5];
% 设置连杆长度
a = [a1,a2,a3,a4,a5];
%设置连杆扭矩角
alpha = [alpha1, alpha2,alpha3,alpha4,alpha5];

L(1)=Link([ 0   d1   a1   alpha1], 'modified');
L(2)=Link([ 0   d2   a2   alpha2], 'modified');L(2).offset = pi/2; 
L(3)=Link([ 0   d3   a3   alpha3], 'modified');L(3).offset = pi/2; 
L(4)=Link([ 0   d4   a4   alpha4], 'modified');L(4).offset = -pi/2; 
L(5)=Link([ 0   d5   a5   alpha5], 'modified');

robot=SerialLink(L,'name','robot');
robot.teach()

%% FK.m 正解函数测试
q1 = [0,0,0,pi/2,0];
%q1 =  [90,-7,0,-50,-7]*pi/180;
T1 = robot.fkine(q1)
T2 = FK(q1,a,d,alpha,l)

%% IK., 逆解函数测试
theta = IK(T2,a,d,l)
robot.plot(theta(1,:));
pause;

%% target_calc.m 函数测试，输入xyz的值，让机械臂执行器达到指定位置
Txyz = target_calc(155,269,0);
theta = IK(Txyz,a,d,l)
robot.plot(theta(1,:))
pause;
Txyz = target_calc(-155,-269,20);
theta = IK(Txyz,a,d,l)
robot.plot(theta(1,:))
pause;


%% path_calc 函数测试,输入目标角度和当前角度等信息，获得轨迹规划
theta_start = [0 0 0 0 0];
theta_final = [pi/2 pi/6 pi/7 -pi/2 0];
v_s = [0 0 0 0 0];
v_f = [0 0 0 0 0];
a_s = [0 0 0 0 0];
a_f = [0 0 0 0 0];
t   = [0 10];

T = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);
q1 = T.motor1.theta;
q2 = T.motor2.theta;
q3 = T.motor3.theta;
q4 = T.motor4.theta;
q5 = T.motor5.theta;

%轨迹规划仿真
num = 1;
for i = 1:numel(q1)-1
    B = [q1(num) q2(num) q3(num) q4(num) q5(num)]
    num = num+1
    subplot(3,2,6)
    robot.plot(B)
end
%% 综合测试

%输入目标x y z 坐标值
box.x = -155;
box.y = -269;
h     = 10;

%计算出物块相对于基坐标的矩阵
Tbox_robo = target_calc(box.x,box.y,h);

%逆解出角度
theta = IK(Tbox_robo,a,d,l)


% 判断是否越界,从四组解中找到一组最适合的解，主要分析关节1/2/3即可
for i = 1:4
 i
 theta(i,1)
 if((-2<theta(i,1))&&(theta(i,1)<2) ...
  && (-1< theta(i,2))&& ( theta(i,2)< 1) ...
  && (-1.67<theta(i,3))&&(theta(i,3)<0.9))

  robot.plot(theta(i,:))
  theta_final = theta(i,:)% 目标位置的四个转角

 end
 pause;
end

%轨迹规划
theta_start= [0 0 0 0 0];
v_s = [0 0 0 0 0];
v_f = [0 0 0 0 0];
a_s = [0 0 0 0 0];
a_f = [0 0 0 0 0];
t   = [0 10];

T = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);
q1 = T.motor1.theta;
q2 = T.motor2.theta;
q3 = T.motor3.theta;
q4 = T.motor4.theta;
q5 = T.motor5.theta;

% 绘制运动图
num = 1;
for i = 1:numel(q1)-1
    B = [q1(num) q2(num) q3(num) q4(num) q5(num)]
    num = num+1
    robot.plot(B)
end


```

#### 机械臂夹取物块完全仿真

视频

<video src="..\Robot_Arm_1.0\img\轨迹规划完全仿真.mp4"></video>

代码

```MATLAB
%% 综合测试
cla
%机械臂初始化
theta_start = [0 0 0 pi/2 0];
v_s = [0 0 0 0 0];
v_f = [0 0 0 0 0];
a_s = [0 0 0 0 0];
a_f = [0 0 0 0 0];
t   = [0 5];
Ttool_box = [0 1 0 0; 1 0 0 0; 0 0 -1 63+15; 0 0 0 1];

%放一个小球
plot_sphere([-155,-269,10],30)

robot.plot(theta_start)
pause;
%=======抓取=======
%发现目标
%输入目标x y z 坐标值
box.x = -155;
box.y = -269;
h     = 10;

%计算出物块相对于基坐标的矩阵
Tbox_robo = target_calc(box.x,box.y,h);

%逆解出角度
theta = IK(Tbox_robo,a,d,l);


% 判断是否越界,从四组解中找到一组最适合的解，主要分析关节1/2/3即可
for i = 1:4
 theta(i,1)
 if((-2<theta(i,1))&&(theta(i,1)<2) ...
  && (-1< theta(i,2))&& ( theta(i,2)< 1) ...
  && (-1.67<theta(i,3))&&(theta(i,3)<0.9))
  theta_final = theta(i,:)% 目标位置的四个转角
 end
end

%规划路径
T = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);
q1 = T.motor1.theta;
q2 = T.motor2.theta;
q3 = T.motor3.theta;
q4 = T.motor4.theta;
q5 = T.motor5.theta;

%轨迹规划仿真
num = 1;
for i = 1:numel(q1)-1
    B = [q1(num) q2(num) q3(num) q4(num) q5(num)]
    num = num+1
    T0_tool = FK(B,a,d,alpha,l);
    T0_box  = T0_tool*Ttool_box;
    P = transl(T0_box)
    %%plot_sphere(P,20)
    robot.plot(B,"fps",60)
end


%%======via_points========
theta_start = theta_final;
theta_final = [0 0 0 pi/2 0]
t   = [5 10];

%规划路径
T = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);
q1 = T.motor1.theta;
q2 = T.motor2.theta;
q3 = T.motor3.theta;
q4 = T.motor4.theta;
q5 = T.motor5.theta;

%轨迹规划仿真
num = 1;
for i = 1:numel(q1)-1
    B = [q1(num) q2(num) q3(num) q4(num) q5(num)]
    num = num+1
    T0_tool = FK(B,a,d,alpha,l);
    T0_box  = T0_tool*Ttool_box;
    P = transl(T0_box)
    plot_sphere(P,2)
    robot.plot(B,"fps",60)
end

plot_sphere(P,30)

%%===========放置=============
theta_start = theta_final;
t   = [10 15];
%输入目标x y z 坐标值
box.x = -155;
box.y = 269;
h     = 10;

%计算出物块相对于基坐标的矩阵
Tbox_robo = target_calc(box.x,box.y,h);

%逆解出角度
theta = IK(Tbox_robo,a,d,l);


% 判断是否越界,从四组解中找到一组最适合的解，主要分析关节1/2/3即可
for i = 1:4
 theta(i,1)
 if((-2<theta(i,1))&&(theta(i,1)<2) ...
  && (-1< theta(i,2))&& ( theta(i,2)< 1) ...
  && (-1.67<theta(i,3))&&(theta(i,3)<0.9))
  %robot.plot(theta(i,:))
  theta_final = theta(i,:)% 目标位置的四个转角
 end
end

%规划路径
T = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);
q1 = T.motor1.theta;
q2 = T.motor2.theta;
q3 = T.motor3.theta;
q4 = T.motor4.theta;
q5 = T.motor5.theta;

%轨迹规划仿真
num = 1;
for i = 1:numel(q1)-1
    B = [q1(num) q2(num) q3(num) q4(num) q5(num)]
    num = num+1
    T0_tool = FK(B,a,d,alpha,l);
    T0_box  = T0_tool*Ttool_box;
    P = transl(T0_box)
    plot_sphere(P,2)
    robot.plot(B,"fps",60)
end

plot_sphere(P,30)
%%======回来========
theta_start = theta_final;
theta_final = [0 0 0 pi/2 0]
t   = [5 10];

%规划路径
T = path_calc(theta_start,theta_final,v_s,v_f,a_s,a_f,t);
q1 = T.motor1.theta;
q2 = T.motor2.theta;
q3 = T.motor3.theta;
q4 = T.motor4.theta;
q5 = T.motor5.theta;

%轨迹规划仿真
num = 1;
for i = 1:numel(q1)-1
    B = [q1(num) q2(num) q3(num) q4(num) q5(num)]
    num = num+1
    T0_tool = FK(B,a,d,alpha,l);
    T0_box  = T0_tool*Ttool_box;
    P = transl(T0_box)
    plot_sphere(P,2)
    robot.plot(B,"fps",60)
end

plot_sphere(P,30)

```



### C语言实现路径规划

##### 第一版路径规划测试

求n次方的函数

```c
//計算n次方
float power(float num,uint16_t n)
{
	float res = 1;
	for(uint16_t i =0;i<n;i++)
	{
		res = res * num;
	}	
	
	return res;
}
```

构造结构体，用来储存数据

- pos_data，用来储存单个关节的初始状态和目标状态信息
- path_message 用来储存路径规划生成的数据，包括位置，速度和加速度

```c
typedef __packed struct
{
  //初始位置和最终位置
	float theta_s;
	float theta_f;
	//初始速度最终速度
	float vel_s;
	float vel_f;
	//初始加速度和最终加速度
	float acc_s;
	float acc_f;
	//初始时间和最终时间
	float t_s;
	float t_f;	
}pos_data;

typedef __packed struct
{
  //储存电机的角度、速度、加速度路径规划 
    float theta[100];
	float   vel[100];
	float   acc[100];
}path_message;

```

路径规划函数

- a_path_cala（pos_data *joint,path_message *path） 能够根据路径规划的计算公式得到theta，vel和acc的值

```C
void a_path_cala(pos_data *joint,path_message *path)
{
	float q0   = joint->theta_s;
	float qf   = joint->theta_f;
    float dq0  = joint->vel_s;
    float dqf  = joint->vel_f;
	float ddq0 = joint->acc_s;
    float ddqf = joint->acc_f;
	float ts   = joint->t_s;
	float tf   = joint->t_f;
	
	
	//计算轨迹五次多项式系数值
	float a0,a1,a2,a3,a4,a5 = 0;
  a0 = q0;
  a1 = dq0;
  a2 = ddq0/2;
	a3 = (20*(qf-q0)-( 8*dqf + 12*dq0)*(tf-ts) - (3*ddq0 -   ddqf)*(tf-ts)*(tf-ts))/(2*(tf-ts)*(tf-ts)*(tf-ts));
	a4 = (30*(q0-qf)+(14*dqf + 16*dq0)*(tf-ts) + (3*ddq0 - 2*ddqf)*(tf-ts)*(tf-ts))/(2*(tf-ts)*(tf-ts)*(tf-ts)*(tf-ts));
	a5 = (12*(qf-q0)-( 6*dqf +  6*dq0)*(tf-ts) - (  ddq0 -   ddqf)*(tf-ts)*(tf-ts))/(2*(tf-ts)*(tf-ts)*(tf-ts)*(tf-ts)*(tf-ts));
	
	uint16_t index = 0;
	//算出轨迹角度、速度和加速度
  for(float t = ts; t < tf ; t+=(tf-ts)/100)
	{
		   //角度計算
			 path->theta[index] =  a0+a1*(t-ts)+a2*power((t-ts),2)+a3*power((t-ts),3)+a4*power((t-ts),4)+a5*power((t-ts),5);
		   //速度計算
		   path->vel[index]   =  a1+2*a2*(t-ts)+3*a3*power((t-ts),2)+4*a4*power((t-ts),3)+5*a5*power((t-ts),4);
			 //加速度计算
		   path->acc[index]   =  2*a2+6*a3*(t-ts)+12*a4*power((t-ts),2)+20*a5*power((t-ts),3);
		   index++;
	}		

}
```

为了验证结果是否正确，使用随机的一个轨迹在CubeMonitor下查看曲线

```c
void path_planning()
{
	
	//规划路径1
    motor_info[1].joint.theta_s = 10;
	motor_info[1].joint.theta_f = 90;
	motor_info[1].joint.vel_s   =  0;
	motor_info[1].joint.vel_f   =  0;
	motor_info[1].joint.acc_s   =  0;
    motor_info[1].joint.acc_f   =  0;
	motor_info[1].joint.t_s     =  0;
	motor_info[1].joint.t_f     = 10;
	
	a_path_cala(&motor_info[1].joint,&motor_info[1].path);
	for(int i =0;i<100;i++)
	{
		theta = motor_info[1].path.theta[i];
		vel   = motor_info[1].path.vel[i];
		acc   = motor_info[1].path.acc[i];
		HAL_Delay(10);
	}
	
	//规划路径2
    motor_info[1].joint.theta_s = 90;
	motor_info[1].joint.theta_f = 45;
	motor_info[1].joint.vel_s   =  0;
	motor_info[1].joint.vel_f   =  0;
	motor_info[1].joint.acc_s   =  0;
    motor_info[1].joint.acc_f   =  0;
	motor_info[1].joint.t_s     = 10;
	motor_info[1].joint.t_f     = 20;
	
	a_path_cala(&motor_info[1].joint,&motor_info[1].path);
	for(int i =0;i<100;i++)
	{
		theta = motor_info[1].path.theta[i];
		vel   = motor_info[1].path.vel[i];
		acc   = motor_info[1].path.acc[i];
		HAL_Delay(10);
	}	
}
```

两点轨迹规划

![轨迹规划曲线](..\Robot_Arm_1.0\img\轨迹规划曲线.png)

多点轨迹规划

![连续轨迹规划](..\Robot_Arm_1.0\img\连续轨迹规划.png)



##### 路径规划改进

创建结构体

```c
//单个电机的数据
typedef __packed struct
{
  //储存电机的角度、速度、加速度路径规划 
  float theta[100];
	float   vel[100];
	float   acc[100];
	
}path_message;

//一条路径的数据
typedef __packed struct
{
	//初始时间和最终时间
	float t_s;
	float t_f;
	//每个电机的路径规划数据
  path_message joint_path[5];
}path;


//一个点而已啦，包含5个关节的角度、速度和加速度数据
//默认为起始点位置
typedef __packed struct
{
	float theta[5];
	float vel[5];
	float acc[5];
}point;

```

路径规划函数

```c
//===============================计算N次方==============================================================
//計算n次方
float power(float num,uint16_t n)
{
	float res = 1;
	for(uint16_t i =0;i<n;i++)
	{
		res = res * num;
	}	
	
	return res;
}
//===============================直接传入两个点，生成这两个点之间所有关节相对路径
void one_path_cala(point *points,point *pointf,path *path)
{
  float ts   = path->t_s;
	float tf   = path->t_f;
	
	for(uint16_t i = 0;i<5;i++)
	{
		float q0   = points->theta[i];
		float qf   = pointf->theta[i];
		float dq0  = points->vel[i];
		float dqf  = pointf->vel[i];
		float ddq0 = points->acc[i];
		float ddqf = pointf->acc[i];

		//计算轨迹五次多项式系数值
		float a0,a1,a2,a3,a4,a5 = 0;
		a0 = q0;
		a1 = dq0;
		a2 = ddq0/2;
		a3 = (20*(qf-q0)-( 8*dqf + 12*dq0)*(tf-ts) - (3*ddq0 -   ddqf)*(tf-ts)*(tf-ts))/(2*(tf-ts)*(tf-ts)*(tf-ts));
		a4 = (30*(q0-qf)+(14*dqf + 16*dq0)*(tf-ts) + (3*ddq0 - 2*ddqf)*(tf-ts)*(tf-ts))/(2*(tf-ts)*(tf-ts)*(tf-ts)*(tf-ts));
		a5 = (12*(qf-q0)-( 6*dqf +  6*dq0)*(tf-ts) - (  ddq0 -   ddqf)*(tf-ts)*(tf-ts))/(2*(tf-ts)*(tf-ts)*(tf-ts)*(tf-ts)*(tf-ts));
		
		uint16_t index = 0;
		//算出轨迹角度、速度和加速度
		for(float t = ts; t < tf ; t+=(tf-ts)/100)
		{
				 //角度計算
				 path->joint_path[i].theta[index] =  a0+a1*(t-ts)+a2*power((t-ts),2)+a3*power((t-ts),3)+a4*power((t-ts),4)+a5*power((t-ts),5);
				 //速度計算
				 path->joint_path[i].vel[index]   =  a1+2*a2*(t-ts)+3*a3*power((t-ts),2)+4*a4*power((t-ts),3)+5*a5*power((t-ts),4);
				 //加速度计算
				 path->joint_path[i].acc[index]   =  2*a2+6*a3*(t-ts)+12*a4*power((t-ts),2)+20*a5*power((t-ts),3);
				 index++;
		}		
	}
	
}
//===============================根据规划的路径，改变关节的target_angle==============================================================
void path_planning(point *points,point *pointf,path *path)
 {
	 //创建一条路径
  one_path_cala(points,pointf,path);
	 
	for(int index =0;index<100;index++)
	{
		for(uint16_t id = 0;id<5;id++)
		{
			motor_info[id].target_angle = path->joint_path[id].theta[index];
			motor_info[id].target_speed = path->joint_path[id].vel[index];
			motor_info[id].target_T_ff  = path->joint_path[id].acc[index];
		}	
		float delay_time = (path->t_f - path->t_s)*10;
		HAL_Delay(delay_time);
	}
 }

 
```

整体实现

```c
//設定上電後的標準位置以及結束時安全掉電的位置
point   reset_point;
point disable_point;
point  via_point;

path    first_path;
path     last_path;
//函数定义
void points_init();

void path_init();

void kinemat_task(void const * argument)
{
   points_init();
	 path_init();
	 path_planning(&reset_point,&via_point,&first_path);
	 path_planning(&via_point,&disable_point,&last_path);
	 while(1)
	{
		
	}
}

//设定基础点
void points_init()
{
   disable_point.theta[0] = -90;
	 disable_point.theta[1] = 20;
	 disable_point.theta[2] = 40;
	 disable_point.theta[3] = 50;
	 disable_point.theta[4] = 90;
	
	 via_point.theta[0] = 50;
	 via_point.theta[1] = 40;
	 via_point.theta[2] = 20;
	 via_point.theta[3] = 10;
	 via_point.theta[4] = 10;
}	

//设定路径
void path_init()
{
	first_path.t_f = 10;
	first_path.t_s = 0;
	
	last_path.t_s =10;
	last_path.t_f =20;
}
```

使用cubemonitor查看曲线，时间和预期轨迹的时间完全一致，符合目标

![路径规划_时间确定](..\Robot_Arm_1.0\img\路径规划_时间确定.png)

##### 第三版路径规划

最后将路径规划用一个函数实现，先创建一个path结构体，用来储存路径信息

```c
//单个电机的数据
typedef __packed struct
{
  //储存电机的角度、速度、加速度路径规划 
    float theta[100];
	float   vel[100];
	float   acc[100];
	
}path_message;
//一个点而已啦，包含5个关节的角度、速度和加速度数据
//默认为起始点位置
typedef __packed struct
{
	float theta[5];
	float vel[5];
	float acc[5];
}point;

//一条路径的数据
typedef __packed struct
{
	//初始时间和最终时间
	float t_s;
	float t_f;
	//每个电机的路径规划数据
  path_message joint_path[5];
	point start;
	point end;
}path;

```

- void path_planning(path *path) 函数，传入参数path，即可实现路径规划

```c
#include "stm32f4xx.h" 
#include "path_planning.h"
#include "cmsis_os.h"
#include "Can_user.h"
static float pi=3.1415;
//===============================计算N次方==============================================================
//計算n次方
float power(float num,uint16_t n)
{
	float res = 1;
	for(uint16_t i =0;i<n;i++)
	{
		res = res * num;
	}	
	
	return res;
}

//===============================直接传入两个点，生成这两个点之间所有关节相对路径==============================================================
//需要传入两个点的角度信息，这条轨迹的时间信息，共三个数据
void one_path_cala(path *path)
{
  float ts   = path->t_s;
	float tf   = path->t_f;
	
	for(uint16_t i = 0;i<5;i++)
	{
		float q0   = path->start.theta[i];
		float qf   = path->end.theta[i];
		float dq0  = path->start.vel[i];
		float dqf  = path->end.vel[i];
		float ddq0 = path->start.acc[i];
		float ddqf = path->end.acc[i];

		//计算轨迹五次多项式系数值
		float a0,a1,a2,a3,a4,a5 = 0;
		a0 = q0;
		a1 = dq0;
		a2 = ddq0/2;
		a3 = (20*(qf-q0)-( 8*dqf + 12*dq0)*(tf-ts) - (3*ddq0 -   ddqf)*(tf-ts)*(tf-ts))/(2*(tf-ts)*(tf-ts)*(tf-ts));
		a4 = (30*(q0-qf)+(14*dqf + 16*dq0)*(tf-ts) + (3*ddq0 - 2*ddqf)*(tf-ts)*(tf-ts))/(2*(tf-ts)*(tf-ts)*(tf-ts)*(tf-ts));
		a5 = (12*(qf-q0)-( 6*dqf +  6*dq0)*(tf-ts) - (  ddq0 -   ddqf)*(tf-ts)*(tf-ts))/(2*(tf-ts)*(tf-ts)*(tf-ts)*(tf-ts)*(tf-ts));
		
		uint16_t index = 0;
		//算出轨迹角度、速度和加速度
		for(float t = ts; t < tf ; t+=(tf-ts)/100)
		{
				 //角度計算
				 path->joint_path[i].theta[index] =  a0+a1*(t-ts)+a2*power((t-ts),2)+a3*power((t-ts),3)+a4*power((t-ts),4)+a5*power((t-ts),5);
				 //速度計算
				 path->joint_path[i].vel[index]   =  a1+2*a2*(t-ts)+3*a3*power((t-ts),2)+4*a4*power((t-ts),3)+5*a5*power((t-ts),4);
				 //加速度计算
				 path->joint_path[i].acc[index]   =  2*a2+6*a3*(t-ts)+12*a4*power((t-ts),2)+20*a5*power((t-ts),3);
				 index++;
		}		
	}
}

//===============================根据规划的路径，改变关节的target_angle==============================================================
void path_planning(path *path)
 {
	 //创建一条路径，先计算
  one_path_cala(path);
	 
	 //算完后再执行路径规划
	for(int index =0;index<100;index++)
	{
		for(uint16_t id = 0;id<5;id++)
		{
			motor_info[id].target_angle = path->joint_path[id].theta[index];
			motor_info[id].target_speed = path->joint_path[id].vel[index];
			motor_info[id].target_T_ff  = path->joint_path[id].acc[index];
		}
		//对角度值进行处理，将电机角度与MATLAB仿真中的角度一一对应
		//将目标角度值赋给电机		
		motor_info[0].target_angle =  path->joint_path[0].theta[index];
		motor_info[1].target_angle = -path->joint_path[1].theta[index];
		motor_info[2].target_angle =  path->joint_path[2].theta[index];
		motor_info[3].target_angle = -path->joint_path[3].theta[index]+pi/2;
		motor_info[4].target_angle =  path->joint_path[4].theta[index];
		
		float delay_time = (path->t_f - path->t_s)*10;
		osDelay(delay_time);
	}
 }

 
```



#### IK逆解

第一版是想通过创建结构体代矩阵，实际用起来非常麻烦，最后决定采用二维数组来代表矩阵

```c
//================================机械臂逆解函数================================
void IK_calc(float (*T)[4],float *res)
{
	//Tans 储存获得的4个解
	
	
	//机械臂参数
    uint16_t a2 = arm.a[1]; uint16_t a3 = arm.a[2];uint16_t a4 = arm.a[3];
	uint16_t d1 = arm.d[0]; uint16_t d5 = arm.d[4];
	
    //T06矩阵
    float r11 = T[0][0];float r12 = T[0][1];float r13 = T[0][2];float px = T[0][3];
    float r21 = T[1][0];float r22 = T[1][1];float r23 = T[1][2];float py = T[1][3];
    float r31 = T[2][0];float r32 = T[2][1];float r33 = T[2][2];float pz = T[2][3];
	
	 //储存theta解
	 float theta1[4]={0};
	 float theta2[4]={0};
     float theta3[4]={0};
	 float theta4[4]={0};
	 float theta5[4]={0};
		 
	 //================================theta1================================
	 theta1[0] = arctan(py,px);
	 theta1[1] = arctan(-py,-px);
	 
	 theta1[2] = theta1[0];
	 theta1[3] = theta1[1];

   //================================theta5================================
	 for(uint16_t i =0;i<2;i++)
	 {
		 theta5[i] = 1;
		 //theta5[i] =  arctan(r21*cos(theta1[i])-r11*sin(theta1[i]),r22*cos(theta1[i])-r12*sin(theta1[i]));
	 }
	 
	 theta5[2] = theta5[0];
	 theta5[3] = theta5[1];
	 //================================theta3 ================================
	 for(uint16_t i =0;i<2;i++)
	 {
		 float x = px*cos(theta1[i]) - d5*(r13*cos(theta1[i]) + r23*sin(theta1[i])) + py*sin(theta1[i]);
		 float y = pz - d1 - d5*r33;
		 
		 if( ((x*x+y*y-a4*a4-a3*a3)/(2*a3*a4))>1 || ((x*x+y*y-a4*a4-a3*a3)/(2*a3*a4))<-1)
		 {
			   theta3[i]   = 255; //表示无解
			   theta3[i+2] = 255; //表示无解
		 }
		 else
		 {
			   theta3[i]   = asin(-(x*x+y*y-a4*a4-a3*a3)/(2*a3*a4));
			   theta3[i+2] = pi - asin(-(x*x+y*y-a4*a4-a3*a3)/(2*a3*a4));
		 }
	 }
	  

	 //判断角度是否越界
	 for(uint16_t i=0;i<4;i++)
	 {
		 if(theta3[i]>3.14)
		 {
				theta3[i] = theta3[i] - 2 * pi;
		 }
		 else if(theta3[i]<-3.14)
		 {
				theta3[i] = theta3[i] + 2 * pi;
		 }
	 }
	 
	
	//================================theta2================================
	 for(uint16_t i=0;i<4;i++)
	 {
		 if(theta3[i]<25)
		 {			
			float s3 = sin(theta3[i]);
			float c3 = cos(theta3[i]);
			float s1 = sin(theta1[i]);
			float c1 = cos(theta1[i]);
			 
			float c2 =  - ((a3 - a4*s3)*(d1 - pz + d5*r33))/(a4*a4*c3*c3 + a4*a4*s3*s3 + a3*a3 - 2*a3*a4*s3) - (a4*c3*(px*c1 - d5*(r13*c1 + r23*s1) + py*s1))/(a4*a4*c3*c3 + a4*a4*s3*s3 + a3*a3 - 2*a3*a4*s3);
      float s2 =    (a4*c3*(d1 - pz + d5*r33))/(a4*a4*c3*c3 + a4*a4*s3*s3 + a3*a3 - 2*a3*a4*s3) - ((a3 - a4*s3)*(px*c1 - d5*(r13*c1 + r23*s1) + py*s1))/(a4*a4*c3*c3 + a4*a4*s3*s3 + a3*a3 - 2*a3*a4*s3);
			
			if(s2>1||s2<-1||c2>1||c2<-1)
			{
				theta2[i] = 255;
			}	
			else
			{
				theta2[i] = arctan(s2,c2); 
			}
		 }
		 else
		 {
			 theta2[i]= 255;
		 }
	 }
	 
	 //判断角度是否越界
	 for(uint16_t i=0;i<4;i++)
	 {
		 if(theta2[i]>3.14)
		 {
				theta2[i] = theta2[i] - 2 * pi;
		 }
		 else if(theta2[i]< - 3.14)
		 {
				theta2[i] = theta2[i] + 2 * pi;
		 }
	 }
	  
	 //================================theta4================================ 
   for(uint16_t i =0;i<4;i++)
	 {
		float s5 = sin(theta5[i]);
		float c5 = cos(theta5[i]);
		float s1 = sin(theta1[i]);
		float c1 = cos(theta1[i]);
		 
		float c4  =  r31*c5 - r32*s5;
		float s4  =  r11*c1*c5 - r12*c1*s5 + r21*c5*s1 - r22*s1*s5;
		theta4[i] =  arctan(-s4,c4) - theta2[i] - theta3[i]; 
	 }
	 	 //判断角度是否越界
	 for(uint16_t i=0;i<4;i++)
	 {
		 if(theta4[i]>3.14)
		 {
				theta4[i] = theta4[i] - 2 * pi;
		 }
		 else if(theta4[i]<-3.14)
		 {
				theta4[i] = theta4[i] + 2 * pi;
		 }
	 }

	 //獲得四個解
	 for(int i = 0;i<4;i++)
	 {
		 Tans[i][0] = theta1[i];
		 Tans[i][1] = theta2[i];
		 Tans[i][2] = theta3[i];
		 Tans[i][3] = theta4[i]; 
		 Tans[i][4] = theta5[i]; 
	 }
	 
	 //=============================解的筛选(处理多解问题)========================================
    //主要分析机械臂的1/2/3关节角度即可
	 for(int i =0;i<4;i++)
	 {
		if((-2<Tans[i][0]&&Tans[i][0]<2)&&(-1<Tans[i][1]&&Tans[i][1]<1)&&(-1.67<Tans[i][2]&&Tans[i][2]<0.9))
		{
		 res[0] = theta1[i];
		 res[1] = theta2[i];
		 res[2] = theta3[i];
		 res[3] = theta4[i]; 
		 res[4] = theta5[i]; 
		}
	 }
	  
}

```

arctan计算优化函数，可以消除一些数据上的偏差

```c
//================================arctan数据处理函数================================
float arctan(float sa,float ca)
{
	float eps = 0.0001;
	float angle = 0;
	
	//abs(cos) = 0 和abs(sin) = 0 的时候，让theta = 0；
	if((fabsf(sa)<eps) && (fabsf(ca)<eps))
	{
		return angle;
	}
	//abs(cos) = 0 的时候，让theta = 90 *（sin的符号）
	if(fabsf(ca) < eps)
	{
		if(sa>0)
		{
			angle =   pi/2;
		}
		if(sa<0)
		{
			angle = - pi/2;
		}
		return angle;
	}
	else if(fabsf(sa) < eps)
	{
		
	}
	else
	{
		
		angle = atan2f(sa,ca);
	}
	
	return angle;
	
	//abs(cos = 0 的时候，让theta = 0   
}

```

物体到执行器末端的映射

```C
//=============输入目标物体位置，获得物体相对于机械臂的变换矩阵================
void target_T_get(float x,float y,float z,float (*T)[4])
{
	T[0][0] = 0;T[0][1] = 1;T[0][2] =  0;T[0][3] = x;
	T[1][0] = 1;T[1][1] = 0;T[1][2] =  0;T[1][3] = y;
	T[2][0] = 0;T[2][1] = 0;T[2][2] = -1;T[2][3] = z+63;
	T[3][0] = 0;T[3][1] = 0;T[3][2] =  0;T[3][3] = 1;

}
```





